```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
pre {
  max-height: 500px;
  overflow-y: auto;
}
pre[class] {
  max-height: 500px;
}
```

# `sgsR` fundamentals {#fund .unnumbered}

## Algorithm structure {#str .unnumbered}

`sgsR` has been scripted primarily using the `terra` package for raster processing and the `sf` package for vector manipulation. There are 3 primary function verbs that the package currently uses:

*   `strat_*` - The stratify verb implies that functions are applying stratification algorithms to an input metrics raster ([`mraster`](#mrast)) and output a stratified raster ([`sraster`](#srast))

*   `sample_*` - The sample verb implies that functions are extracting samples from [`srasters`](#srast) produced from `strat_*` functions. A few algorithms (e.g. [`sample_srs`](#sample), [`sample_balanced`](#balanced), [`sample_grid`](#grid)) are able to take [`mrasters`](#mrast) as inputs as they are not dependent on stratified inputs for sampling.

*   `calculate_*` - The calculate verb implies that functions are performing calculations to be used in consequent processing. The use of predefined sample analysis algorithms ([`calculate_ahels`](#ahels), [`calculate_coobs`](#coobs)) are also included.

::: {.box-content .vig-content}
::: {.box-title .vig-content-top}
### Package Documentation {.unnumbered}
:::
I do not go into detail about the intricacies of each function in this document. Please see the documentation for functions e.g. `?sgsR::strat_kmeans` for intended application and use of each function.
:::

## Example data {.unnumbered}
Worked examples of all functions are provided using data internal to the package. To load internal `mraster` and road [`access`](#access) data we use the following code. Follow along on your own machine to see more outputs and get a better sense of how the package functions.

### Metrics rasters - `mraster` {#mrast .unnumbered}
```{r,warning=F,message=F}
library(sgsR)
library(terra)
library(sf)

#--- Load mraster and access files ---#
r <- system.file("extdata", "wall_metrics_small.tif", package = "sgsR")

#--- load the mraster using the terra package ---#
mraster <- terra::rast(r)
```

### Road `access` data {#vect .unnumbered}
```{r,warning=F,message=F}
a <- system.file("extdata", "roads.shp", package = "sgsR")

#--- load the access vector using the sf package ---#
access <- sf::st_read(a)
```

```{r,warning=F,message=F}
terra::plot(mraster[[1]])
terra::plot(access, add = TRUE, col = "black")

```

From the plot we see the first band (`zmax`) of the `mraster` with the `access` vector overlaid. 

## Stratified rasters - `sraster` {#srast .unnumbered}

For the purposes of this tutorial I am also going to show how to produce a basic `sraster` and `existing` sample data that we will used in examples below. 

To make the `sraster` we will use the [`strat_kmeans`](#kmeans) function where the input `mraster` will be stratified using a kmeans algorithm.

```{r,warning=F,message=F}
#--- apply kmeans algorithm to metrics raster ---#
sraster <- strat_kmeans(mraster = mraster, # use mraster as input for sampling
                        nStrata = 4, # algorithm will produce 4 strata
                        plot = TRUE) # algorithm will plot output

```

After the `sraster` is produced we apply the [`sample_srs`](#srs) algorithm which randomly samples points within our `sraster` to produce an `existing` sample dataset.

```{r,warning=F,message=F}
#--- set seed ---#
set.seed(2021)

#--- apply kmeans algorithm to metrics raster ---#
existing <- sample_srs(raster = mraster, # use mraster as input for sampling
                       nSamp = 200, # request 200 samples be taken
                       mindist = 100, # define that samples must be 100 m apart
                       plot = TRUE) # algorithm will plot output

```

We now have `mraster`, `access`, `sraster` and `existing` data sets generated. Expect to see these data used in the all examples in this document.

